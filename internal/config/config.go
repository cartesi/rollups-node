// (c) Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: Apache-2.0 (see LICENSE)

// The config package handles all of the node's configurations,
// which are mostly obtained through environment variables.
//
// The get.go file contains most of the getter functions for the configuration values.
// Its code is automatically generated by the generate/main.go script,
// given the environment variable configured in the generate/Config.toml file.
//
// Custom getters are defined in the config.go file.
package config

import (
	"fmt"
	"log"
	"os"
	"strconv"
	"sync"
	"time"
)

//go:generate go run ./generate

// ------------------------------------------------------------------------------------------------
// Parsing functions
// ------------------------------------------------------------------------------------------------

func toInt64FromString(s string) (int64, error) {
	return strconv.ParseInt(s, 10, 64)
}

func toStringFromString(s string) (string, error) {
	return s, nil
}

func toDurationFromSeconds(s string) (time.Duration, error) {
	return time.ParseDuration(s + "s")
}

// Aliases to be used by the generated functions.
var (
	toBool     = strconv.ParseBool
	toInt      = strconv.Atoi
	toInt64    = toInt64FromString
	toString   = toStringFromString
	toDuration = toDurationFromSeconds
	toLogLevel = toLogLevelFromString
)

// ------------------------------------------------------------------------------------------------
// Custom GETs
// ------------------------------------------------------------------------------------------------

func GetAuth() Auth {
	// getting the (optional) account index
	index, _ := getCartesiAuthMnemonicAccountIndex()

	// if the mnemonic is coming from an environment variable
	if mnemonic, ok := getCartesiAuthMnemonic(); ok {
		return AuthMnemonic{Mnemonic: mnemonic, AccountIndex: index}
	}

	// if the mnemonic is coming from a file
	if file, ok := getCartesiAuthMnemonicFile(); ok {
		mnemonic, err := os.ReadFile(file)
		if err != nil {
			fail("mnemonic file error: %s", err)
		}
		return AuthMnemonic{Mnemonic: string(mnemonic), AccountIndex: index}
	}

	// if we are not using mnemonics, but AWS authentication
	keyID, ok1 := getCartesiAuthAwsKmsKeyId()
	region, ok2 := getCartesiAuthAwsKmsRegion()
	if !ok1 || !ok2 {
		fail("missing auth environment variables")
	}
	return AuthAWS{KeyID: keyID, Region: region}
}

// ------------------------------------------------------------------------------------------------
// Get Helpers
// ------------------------------------------------------------------------------------------------

// Cache of environment variable values
var cache struct {
	sync.Mutex
	values map[string]string
}

var configLogger = log.New(os.Stdout, "CONFIG ", log.LstdFlags)

func init() {
	cache.values = make(map[string]string)
}

// Reads the value of an environment variable (loads from a cached value when possible).
// It returns the value read and true if the variable was set,
// otherwise it returns the empty string and false.
func read(name string, redact bool) (string, bool) {
	cache.Lock()
	defer cache.Unlock()
	if s, ok := cache.values[name]; ok {
		return s, true
	} else if s, ok := os.LookupEnv(name); ok {
		if !redact {
			configLogger.Printf("read %s environment variable: %v", name, s)
		}
		cache.values[name] = s
		return s, true
	} else {
		return "", false
	}
}

// Parses a string using a given function.
// It fails on a parsing error, otherwise returns the parsed value.
func parse[T any](s string, f func(string) (T, error)) T {
	v, err := f(s)
	if err != nil {
		fail("parsing error: %s", err)
	}
	return v
}

// Returns a zero value and false or the value of an environment variable and true.
//
// If the variable could not be read from the environment and it has a default value,
// then this function will set the cache with the default value and return it parsed.
func getOptional[T any](
	name string,
	default_ string,
	hasDefault bool,
	redact bool,
	parser func(string) (T, error)) (T, bool) {

	if s, ok := read(name, redact); ok {
		v := parse(s, parser)
		return v, true
	}

	if hasDefault {
		cache.Lock()
		defer cache.Unlock()
		cache.values[name] = default_
		v := parse(default_, parser)
		return v, true
	}

	var zeroValue T
	return zeroValue, false
}

// Same as getOptional, but fails instead of returning a zero value and false.
func get[T any](
	name string,
	defaultValue string,
	hasDefault bool,
	redact bool,
	parser func(string) (T, error)) T {
	v, ok := getOptional(name, defaultValue, hasDefault, redact, parser)
	if !ok {
		fail("missing required %s env var", name)
	}

	return v
}

func fail(s string, v ...any) {
	fmt.Fprintf(os.Stderr, s+"\n", v...)
	os.Exit(1)
}
